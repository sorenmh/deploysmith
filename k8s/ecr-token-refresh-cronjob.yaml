apiVersion: v1
kind: ServiceAccount
metadata:
  name: ecr-token-refresher
  namespace: default

---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: ecr-token-refresher
  namespace: default
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list", "create", "update", "patch", "delete"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: ecr-token-refresher
  namespace: default
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: ecr-token-refresher
subjects:
- kind: ServiceAccount
  name: ecr-token-refresher
  namespace: default

---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: ecr-token-refresh
  namespace: default
  labels:
    app: ecr-token-refresh
spec:
  schedule: "0 */6 * * *"  # Every 6 hours
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 1
  concurrencyPolicy: Forbid
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app: ecr-token-refresh
        spec:
          serviceAccountName: ecr-token-refresher
          restartPolicy: OnFailure
          containers:
          - name: ecr-token-refresh
            image: amazon/aws-cli:2.13.0
            imagePullPolicy: IfNotPresent
            command:
            - /bin/bash
            - -c
            - |
              set -e

              echo "Starting ECR token refresh at $(date)"

              # Install kubectl
              curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
              chmod +x kubectl
              mv kubectl /usr/local/bin/

              # Get ECR registry URL from config
              REGISTRY_URL="${ECR_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com"

              echo "Getting ECR login token for registry: $REGISTRY_URL"

              # Get new ECR token
              TOKEN=$(aws ecr get-login-password --region $AWS_DEFAULT_REGION)

              if [ -z "$TOKEN" ]; then
                echo "Error: Failed to get ECR token"
                exit 1
              fi

              echo "Successfully retrieved ECR token"

              # Create new secret data
              SECRET_NAME="${ECR_SECRET_NAME:-ecr-credentials}"

              echo "Creating/updating Kubernetes secret: $SECRET_NAME"

              # Delete existing secret if it exists (ignore errors)
              kubectl delete secret "$SECRET_NAME" --ignore-not-found=true

              # Create new secret
              kubectl create secret docker-registry "$SECRET_NAME" \
                --docker-server="$REGISTRY_URL" \
                --docker-username=AWS \
                --docker-password="$TOKEN" \
                --dry-run=client -o yaml | kubectl apply -f -

              echo "Successfully updated ECR credentials secret"

              # Restart deployments that use ECR images (optional)
              if [ "$RESTART_DEPLOYMENTS" = "true" ]; then
                echo "Restarting deployments that use ECR images..."

                # Find deployments using ECR images
                kubectl get deployments -o json | \
                  jq -r ".items[] | select(.spec.template.spec.containers[]?.image | contains(\"$ECR_ACCOUNT_ID.dkr.ecr\")) | .metadata.name" | \
                  while read -r deployment; do
                    if [ -n "$deployment" ]; then
                      echo "Restarting deployment: $deployment"
                      kubectl rollout restart deployment/"$deployment"
                    fi
                  done
              fi

              echo "ECR token refresh completed successfully at $(date)"

            env:
            - name: AWS_DEFAULT_REGION
              valueFrom:
                secretKeyRef:
                  name: deployment-api-secrets
                  key: aws-region
            - name: ECR_ACCOUNT_ID
              valueFrom:
                secretKeyRef:
                  name: deployment-api-secrets
                  key: aws-account-id
            - name: ECR_SECRET_NAME
              value: "ecr-credentials"
            - name: RESTART_DEPLOYMENTS
              value: "false"
            - name: AWS_ACCESS_KEY_ID
              valueFrom:
                secretKeyRef:
                  name: deployment-api-secrets
                  key: aws-access-key-id
            - name: AWS_SECRET_ACCESS_KEY
              valueFrom:
                secretKeyRef:
                  name: deployment-api-secrets
                  key: aws-secret-access-key
            resources:
              requests:
                memory: "64Mi"
                cpu: "50m"
              limits:
                memory: "128Mi"
                cpu: "200m"

# Note: This CronJob uses the existing deployment-api-secrets
# Make sure the secret includes:
# - aws-account-id
# - aws-access-key-id
# - aws-secret-access-key
# - aws-region